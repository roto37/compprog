//巡回セールスマン問題
//O[n^2 * 2^n]
//ある重み付き有向グラフにおいて、ある頂点からスタートしてすべての頂点をちょうど
//1回づつ訪れ、初めの頂点に戻ってくるのにかかる最短経路距離を考える。

//ある頂点からスタートと書いたが実はそれはどこでもよい。(背理法で示す)
/*証明：適当に頂点を一つ選んできて(sとする)、そこからスタートして他の頂点を1回づつ訪れ戻ってきたときの
最短距離がdだったとする。
このとき、最短経路ではすべての頂点(始点も含めて)において、1本づつ入る、出ていく辺がある。
もしs以外の別の頂点からスタートして距離がd未満であるとすると、その時の経路もsに入る、出ていく辺は1本ずつ
であるから、sからスタートしてもそのような閉路は形成できるのでd未満であることは矛盾
よって次のことが言える
ある頂点からスタートして求まった最短経路<=>すべての頂点に対してそこからスタートしたときの最短経路*/

int n, m;
int g[20][20];
int dp[1<<15][15];

signed main(){
    cin.tie(0);
    ios::sync_with_stdio(false);
    cin >> n >> m;
    rep(i, n)rep(j, n) g[i][j] = INT_MAX;
    rep(i, m) {
        int s, t, d;
        cin >> s >> t >> d;
        g[s][t] = d;
    }
    //初期化, startはどこでもよい(以下では0)
    rep(i, 1<<n)rep(j, n) dp[i][j] = INT_MAX;
    int start = 0;
    dp[1<<start][start] = 0;

    rep(i, 1<<n) {
        rep(j, n) {
            if (i>>j & 1) {
                rep(k, n) {
                    dp[i][j] = min(dp[i][j], dp[i^(1<<j)][k] + g[k][j]);
                }
            }
        }
    }
    //startにもどってくる
    int ans = INT_MAX;
    rep(j, n) ans = min(ans, dp[(1<<n) - 1][j] + g[j][start]);

    cout << (ans == INT_MAX ? -1 : ans) << endl;
}
